"""
Sistema de Feedback Visual em ASCII - ETAPA 5
Implementa indicadores visuais criativos para terminal/console
Seguindo especifica√ß√µes Gemini AI para otimizar percep√ß√£o de performance
"""

import time
import threading
import sys
import itertools
from typing import List, Dict, Optional, Callable
from datetime import datetime
from enum import Enum

# Logger
try:
    from utils.logger import get_logger
except ImportError:
    class SimpleLogger:
        def __init__(self, name): self.name = name
        def info(self, msg): print(f"[INFO] {msg}")
        def warning(self, msg): print(f"[WARNING] {msg}")
        def error(self, msg): print(f"[ERROR] {msg}")
        def debug(self, msg): print(f"[DEBUG] {msg}")
    def get_logger(name): return SimpleLogger(name)

logger = get_logger(__name__)


class FeedbackType(Enum):
    """Tipos de feedback visual"""
    THINKING = "thinking"                    # Geral/Pensando
    API_CALL = "api_call"                   # Aguardando API LLM
    MEMORY_ACCESS = "memory_access"         # Buscando na mem√≥ria
    AGENT_WORKING = "agent_working"         # Executando agente
    INITIALIZATION = "initialization"       # Inicializa√ß√£o do sistema
    LONG_OPERATION = "long_operation"       # Opera√ß√£o longa com etapas
    QUICK_RESPONSE = "quick_response"       # Resposta r√°pida
    ERROR = "error"                         # Erro cr√≠tico
    WARNING = "warning"                     # Erro de valida√ß√£o
    SUCCESS = "success"                     # Opera√ß√£o bem-sucedida


class VisualIndicator:
    """
    Indicador visual animado para terminal
    Implementa especifica√ß√µes Gemini de feedback criativo
    """
    
    def __init__(self, feedback_type: FeedbackType, message: str = "", 
                 duration: float = None):
        self.feedback_type = feedback_type
        self.message = message
        self.duration = duration
        self.is_running = False
        self.thread = None
        
        # Configura√ß√µes de anima√ß√£o por tipo (Gemini specs)
        self.animations = {
            FeedbackType.THINKING: {
                "frames": ["üß†   ", "üß† . ", "üß† ..", "üß† ..."],
                "interval": 0.5,
                "prefix": "üß† Pensando",
                "suffix": ""
            },
            
            FeedbackType.API_CALL: {
                "frames": ["‚ö°   API", "‚ö° . API", "‚ö° ..API", "‚ö° ...API"],
                "interval": 0.4,
                "prefix": "‚ö° Consultando Claude",
                "suffix": ""
            },
            
            FeedbackType.MEMORY_ACCESS: {
                "frames": ["üìñ   ", "üìñ . ", "üìñ ..", "üìñ ..."],
                "interval": 0.3,
                "prefix": "üìñ Acessando mem√≥ria",
                "suffix": ""
            },
            
            FeedbackType.AGENT_WORKING: {
                "frames": ["‚öôÔ∏è   ", "‚öôÔ∏è . ", "‚öôÔ∏è ..", "‚öôÔ∏è ..."],
                "interval": 0.4,
                "prefix": "‚öôÔ∏è Agente trabalhando",
                "suffix": ""
            },
            
            FeedbackType.QUICK_RESPONSE: {
                "frames": ["‚ú®"],
                "interval": 0.1,
                "prefix": "‚ú®",
                "suffix": "",
                "single_shot": True
            },
            
            FeedbackType.SUCCESS: {
                "frames": ["‚úÖ"],
                "interval": 0.1,
                "prefix": "‚úÖ",
                "suffix": "",
                "single_shot": True
            }
        }
    
    def start(self):
        """Inicia anima√ß√£o"""
        if self.is_running:
            return
        
        self.is_running = True
        self.thread = threading.Thread(target=self._animate, daemon=True)
        self.thread.start()
    
    def stop(self):
        """Para anima√ß√£o"""
        self.is_running = False
        if self.thread:
            self.thread.join(timeout=1.0)
        
        # Limpar linha
        self._clear_line()
    
    def _animate(self):
        """Loop de anima√ß√£o"""
        config = self.animations.get(self.feedback_type, self.animations[FeedbackType.THINKING])
        frames = config["frames"]
        interval = config["interval"]
        prefix = config.get("prefix", "")
        is_single_shot = config.get("single_shot", False)
        
        if is_single_shot:
            # Mostrar uma vez e sair
            display_text = f"\r{prefix} {self.message}"
            print(display_text, end="", flush=True)
            time.sleep(interval)
            return
        
        # Anima√ß√£o cont√≠nua
        frame_cycle = itertools.cycle(frames)
        start_time = time.time()
        
        while self.is_running:
            if self.duration and (time.time() - start_time) > self.duration:
                break
            
            frame = next(frame_cycle)
            display_text = f"\r{frame} {prefix}"
            if self.message:
                display_text += f": {self.message}"
            
            print(display_text, end="", flush=True)
            time.sleep(interval)
    
    def _clear_line(self):
        """Limpa linha atual"""
        print("\r" + " " * 80 + "\r", end="", flush=True)


class ProgressBar:
    """
    Barra de progresso ASCII para inicializa√ß√£o
    Implementa especifica√ß√£o Gemini para opera√ß√µes longas
    """
    
    def __init__(self, total_steps: int, width: int = 20):
        self.total_steps = total_steps
        self.current_step = 0
        self.width = width
        self.start_time = time.time()
        
    def update(self, step: int, message: str = ""):
        """Atualiza progresso"""
        self.current_step = step
        percentage = (step / self.total_steps) * 100
        filled = int(self.width * step / self.total_steps)
        empty = self.width - filled
        
        bar = "=" * filled + " " * empty
        elapsed = time.time() - self.start_time
        
        display = f"\r[{bar}] {percentage:5.1f}% {message}"
        print(display, end="", flush=True)
        
        if step >= self.total_steps:
            print()  # Nova linha ao completar
    
    def complete(self, final_message: str = "Conclu√≠do!"):
        """Completa barra de progresso"""
        self.update(self.total_steps, final_message)


class MultiStageProgress:
    """
    Indicador de progresso multi-etapas para opera√ß√µes complexas
    Implementa especifica√ß√£o Gemini para Or√°culo e DeepAgent
    """
    
    def __init__(self, stages: List[str]):
        self.stages = stages
        self.current_stage = 0
        self.total_stages = len(stages)
        
    def next_stage(self, custom_message: str = None):
        """Avan√ßa para pr√≥xima etapa"""
        if self.current_stage < self.total_stages:
            stage_num = self.current_stage + 1
            stage_message = custom_message or self.stages[self.current_stage]
            
            print(f"\r‚è≥ ({stage_num}/{self.total_stages}) {stage_message}...", end="", flush=True)
            self.current_stage += 1
            
            time.sleep(0.5)  # Pequena pausa para visibilidade
    
    def complete(self, final_message: str = "Processo conclu√≠do!"):
        """Finaliza progresso multi-etapas"""
        print(f"\rüåü {final_message}")


class ErrorDisplay:
    """
    Sistema de exibi√ß√£o de erros com personalidade
    Implementa especifica√ß√£o Gemini para respostas de erro amig√°veis
    """
    
    @staticmethod
    def show_critical_error(error_message: str = ""):
        """Erro cr√≠tico/inesperado"""
        error_display = """
üö® OOPS! Algo deu muito errado. üö®
Carlos: "Sinto muito, tive um pequeno curto-circuito cerebral. 
Por favor, tente novamente ou verifique os logs."
        """.strip()
        
        if error_message:
            error_display += f"\n\nüí° Detalhes t√©cnicos: {error_message}"
        
        print(f"\n{error_display}\n")
    
    @staticmethod
    def show_validation_error(user_input: str = ""):
        """Erro de valida√ß√£o (entrada inv√°lida)"""
        error_display = """
‚ö†Ô∏è Entendi errado. ‚ö†Ô∏è
Carlos: "Parece que sua solicita√ß√£o n√£o est√° clara. 
Poderia reformular ou me dar mais detalhes?"
        """.strip()
        
        if user_input:
            error_display += f"\n\nüí≠ Voc√™ disse: '{user_input}'"
        
        print(f"\n{error_display}\n")
    
    @staticmethod
    def show_timeout_error(agent_name: str = ""):
        """Timeout com personalidade do Carlos"""
        timeout_messages = [
            "Hmm, parece que um dos meus assistentes est√° meditando profundamente. Ele vai voltar em breve, por favor, tente novamente em um minuto.",
            "A conex√£o com o mundo exterior (ou talvez um agente pensador demais) demorou a responder. Tente de novo, a paci√™ncia √© uma virtude digital!",
            "Ops! Um dos agentes ficou filosofando demais. Vamos tentar de novo?"
        ]
        
        import random
        message = random.choice(timeout_messages)
        
        if agent_name:
            message = message.replace("um dos meus assistentes", f"o {agent_name}")
            message = message.replace("um agente", f"o {agent_name}")
        
        print(f"\n‚è∞ Carlos: \"{message}\"\n")
    
    @staticmethod  
    def show_api_error():
        """Erro de API com explica√ß√£o amig√°vel"""
        api_messages = [
            "Oops! Houve um pequeno contratempo na comunica√ß√£o com meus servidores de conhecimento (API). Pode ser algo tempor√°rio, por favor, me d√™ outra chance.",
            "Parece que a ponte para a internet est√° com problemas. N√£o se preocupe, estou investigando! Tente de novo em instantes.",
            "Houston, temos um problema! A conex√£o com o espa√ßo digital falhou. Mas j√° estou trabalhando na solu√ß√£o!"
        ]
        
        import random
        message = random.choice(api_messages)
        
        print(f"\nüîå Carlos: \"{message}\"\n")
    
    @staticmethod
    def show_overload_error():
        """Sistema sobrecarregado"""
        overload_messages = [
            "Puxa, estou com muitos pensamentos na cabe√ßa agora! Minha capacidade est√° no limite. Poder√≠amos tentar uma pergunta mais simples ou voltar em alguns minutos?",
            "Estou recebendo muitas requisi√ß√µes neste momento. Para garantir que eu responda com qualidade, sugiro que tente com uma solicita√ß√£o menos complexa ou espere um pouco.",
            "Meu c√©rebro digital est√° no limite! Que tal uma pergunta mais leve enquanto me organizo?"
        ]
        
        import random
        message = random.choice(overload_messages)
        
        print(f"\nüß†üí• Carlos: \"{message}\"\n")


class VisualFeedbackManager:
    """
    Gerenciador central de feedback visual
    Coordena todos os tipos de indicadores visuais
    """
    
    def __init__(self):
        self.active_indicators: Dict[str, VisualIndicator] = {}
        self.feedback_history: List[Dict] = []
        
        logger.info("üé® VisualFeedbackManager inicializado")
    
    def show_thinking(self, message: str = "Analisando sua solicita√ß√£o"):
        """Mostra indicador de pensamento geral"""
        return self._start_indicator("thinking", FeedbackType.THINKING, message)
    
    def show_api_call(self, message: str = "Consultando intelig√™ncia artificial"):
        """Mostra indicador de chamada √† API"""
        return self._start_indicator("api_call", FeedbackType.API_CALL, message)
    
    def show_memory_access(self, message: str = "Consultando mem√≥ria"):
        """Mostra indicador de acesso √† mem√≥ria"""
        return self._start_indicator("memory_access", FeedbackType.MEMORY_ACCESS, message)
    
    def show_agent_working(self, agent_name: str, task: str = "processando"):
        """Mostra indicador de agente trabalhando"""
        message = f"{agent_name} {task}"
        return self._start_indicator("agent_working", FeedbackType.AGENT_WORKING, message)
    
    def show_quick_response(self, message: str = ""):
        """Mostra indicador de resposta r√°pida"""
        indicator = VisualIndicator(FeedbackType.QUICK_RESPONSE, message)
        indicator.start()
        time.sleep(0.2)
        indicator.stop()
        return indicator
    
    def show_success(self, message: str = ""):
        """Mostra indicador de sucesso"""
        indicator = VisualIndicator(FeedbackType.SUCCESS, message)
        indicator.start() 
        time.sleep(0.3)
        indicator.stop()
        return indicator
    
    def show_initialization(self, steps: List[str]) -> ProgressBar:
        """Mostra barra de progresso de inicializa√ß√£o"""
        print("\nGPTMA V5.0 Inicializando...")
        progress = ProgressBar(len(steps))
        
        for i, step in enumerate(steps):
            progress.update(i + 1, step)
            time.sleep(0.3)  # Simular tempo de carregamento
        
        return progress
    
    def show_long_operation(self, agent_name: str, stages: List[str]) -> MultiStageProgress:
        """Mostra progresso de opera√ß√£o longa com etapas"""
        print(f"\nüåü {agent_name}: Iniciando processo...")
        return MultiStageProgress(stages)
    
    def stop_indicator(self, indicator_id: str):
        """Para indicador espec√≠fico"""
        if indicator_id in self.active_indicators:
            self.active_indicators[indicator_id].stop()
            del self.active_indicators[indicator_id]
    
    def stop_all_indicators(self):
        """Para todos os indicadores ativos"""
        for indicator in self.active_indicators.values():
            indicator.stop()
        self.active_indicators.clear()
    
    def _start_indicator(self, indicator_id: str, feedback_type: FeedbackType, 
                        message: str) -> VisualIndicator:
        """Inicia indicador e adiciona ao gerenciamento"""
        # Parar indicador anterior se existir
        if indicator_id in self.active_indicators:
            self.active_indicators[indicator_id].stop()
        
        # Criar e iniciar novo indicador
        indicator = VisualIndicator(feedback_type, message)
        self.active_indicators[indicator_id] = indicator
        indicator.start()
        
        # Adicionar ao hist√≥rico
        self.feedback_history.append({
            "timestamp": datetime.now(),
            "type": feedback_type.value,
            "message": message,
            "indicator_id": indicator_id
        })
        
        return indicator
    
    def get_feedback_stats(self) -> Dict:
        """Retorna estat√≠sticas de feedback"""
        type_counts = {}
        for entry in self.feedback_history:
            type_name = entry["type"]
            type_counts[type_name] = type_counts.get(type_name, 0) + 1
        
        return {
            "total_feedbacks": len(self.feedback_history),
            "active_indicators": len(self.active_indicators),
            "type_distribution": type_counts
        }


# Singleton global
_feedback_manager_instance = None


def get_visual_feedback_manager() -> VisualFeedbackManager:
    """Retorna inst√¢ncia singleton do VisualFeedbackManager"""
    global _feedback_manager_instance
    
    if _feedback_manager_instance is None:
        _feedback_manager_instance = VisualFeedbackManager()
    
    return _feedback_manager_instance


# Context manager para feedback autom√°tico
class FeedbackContext:
    """Context manager para feedback visual autom√°tico"""
    
    def __init__(self, feedback_type: str, message: str = ""):
        self.feedback_type = feedback_type
        self.message = message
        self.manager = get_visual_feedback_manager()
        self.indicator = None
    
    def __enter__(self):
        # Mapear tipos para m√©todos
        method_map = {
            "thinking": self.manager.show_thinking,
            "api_call": self.manager.show_api_call,
            "memory_access": self.manager.show_memory_access,
            "agent_working": self.manager.show_agent_working
        }
        
        method = method_map.get(self.feedback_type, self.manager.show_thinking)
        self.indicator = method(self.message)
        return self.indicator
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.indicator:
            self.indicator.stop()


# Teste do sistema
if __name__ == "__main__":
    print("üß™ TESTE DO SISTEMA DE FEEDBACK VISUAL")
    print("=" * 60)
    
    manager = get_visual_feedback_manager()
    
    # Teste 1: Indicadores b√°sicos
    print("\n1. üß† Teste de Pensamento (3s)")
    indicator = manager.show_thinking("Analisando sua solicita√ß√£o")
    time.sleep(3)
    indicator.stop()
    
    print("\n2. ‚ö° Teste de API Call (2s)")
    indicator = manager.show_api_call("Consultando Claude")
    time.sleep(2)
    indicator.stop()
    
    print("\n3. üìñ Teste de Mem√≥ria (2s)")
    indicator = manager.show_memory_access("Buscando informa√ß√µes anteriores")
    time.sleep(2)
    indicator.stop()
    
    print("\n4. ‚öôÔ∏è Teste de Agente (2s)")
    indicator = manager.show_agent_working("Or√°culo", "deliberando")
    time.sleep(2)
    indicator.stop()
    
    # Teste 2: Respostas r√°pidas
    print("\n5. ‚ú® Teste de Resposta R√°pida")
    manager.show_quick_response("Comando processado")
    
    print("\n6. ‚úÖ Teste de Sucesso")
    manager.show_success("Opera√ß√£o conclu√≠da")
    
    # Teste 3: Barra de progresso
    print("\n7. üìä Teste de Inicializa√ß√£o")
    steps = ["Carregando M√≥dulos", "Ativando Agentes", "Conectando APIs", "Sistema Pronto"]
    progress = manager.show_initialization(steps)
    
    # Teste 4: Opera√ß√£o multi-etapas
    print("\n8. üåü Teste de Opera√ß√£o Longa")
    stages = ["Coletando informa√ß√µes", "Analisando dados", "Chegando a uma conclus√£o"]
    multi_progress = manager.show_long_operation("Or√°culo", stages)
    
    for stage in stages:
        multi_progress.next_stage()
        time.sleep(1)
    
    multi_progress.complete("Delibera√ß√£o conclu√≠da!")
    
    # Teste 5: Erros com personalidade
    print("\n9. üö® Teste de Erros")
    
    print("\nüìå Erro Cr√≠tico:")
    ErrorDisplay.show_critical_error("Conex√£o perdida")
    
    print("üìå Erro de Valida√ß√£o:")
    ErrorDisplay.show_validation_error("comando inv√°lido")
    
    print("üìå Timeout:")
    ErrorDisplay.show_timeout_error("Or√°culo")
    
    print("üìå Erro de API:")
    ErrorDisplay.show_api_error()
    
    print("üìå Sistema Sobrecarregado:")
    ErrorDisplay.show_overload_error()
    
    # Teste 6: Context Manager
    print("\n10. üîÑ Teste de Context Manager")
    with FeedbackContext("thinking", "Processando com context manager"):
        time.sleep(2)
        print("\r‚úÖ Processamento conclu√≠do com context manager!")
    
    # Estat√≠sticas
    stats = manager.get_feedback_stats()
    print(f"\nüìä ESTAT√çSTICAS DE FEEDBACK:")
    print(f"   Total de feedbacks: {stats['total_feedbacks']}")
    print(f"   Indicadores ativos: {stats['active_indicators']}")
    print(f"   Distribui√ß√£o por tipo: {stats['type_distribution']}")
    
    print(f"\n‚úÖ TESTE CONCLU√çDO - Sistema de feedback visual funcionando!")